---
title: De l'al√©atoire en CSS, c'est possible ! Enfin, presque...
slug: de-l-aleatoire-en-css-c-est-possible-enfin-presque
description: Sauf √† vouloir s'aventurer en eaux troubles, JavaScript est plus indiqu√©... Mais pour combien de temps ?
date: 2024-10-14
tags:
  - CSS
  - JavaScript
layout: layouts/post.njk
---

Pour la sortie de ce nouveau blog, il me fallait mettre en place un effet visuel renversant, qui impressionnerait la galerie et montrerait toute l'√©tendue de mes capacit√©s.

Comme je n'avais pas le temps de faire cela, j'ai cod√© un effet rigolo de survol : lorsque la souris est pass√©e sur ma photo, deux √©mojis parmi une centaine soigneusement s√©lectionn√©s apparaissent al√©atoirement.

{% video "photo.webm", "La souris survole ma photo. √Ä chaque survol, deux √©mojis al√©atoires recouvrent mes yeux." %}

Du grand art, je vous dis.

Cela a soulev√© une question int√©ressante : quelle serait la meilleure m√©thode pour s√©lectionner l'√©moji al√©atoirement ? CSS suffirait-t-il ?

## CSS : la roulette invisible

La roulette invisible, c'est le petit nom que je donne √† cette technique que je n'ai pas invent√©e, mais qui est int√©ressante. Je vous explique.

Tout commence avec un pseudo-√©l√©ment vide.

```css
div::before {
  content: '';
}
```

Appliquons √† ce pseudo-√©l√©ment une animation `emojis`. Son but ? Changer le contenu de la propri√©t√© `content` pour y injecter nos √©mojis. Pour l'instant, trois suffiront.

```css
div::before {
  content: '';
  animation: emojis 1s linear infinite;
}

@keyframes emojis {
  0% {
    content: "üí•" / "";
  }

  50% {
    content: "üê∏" / "";
  }

  100% {
    content: "üéâ" / "";
  }
}
```

{% aside %}
Note : la syntaxe <code>content: "üéâ" / ""</code> permet de d√©finir, dans la seconde string, le texte alternatif pour ce pseudo-√©l√©ment, qui pourra √™tre lu par les technologies d'assistance. Quand on utilise un pseudo-√©l√©ment √† des fins d√©coratives, il est donc recommand√© d'utiliser une cha√Æne vide pour √©viter que le contenu de l'√©moji ne soit interpr√©t√©, par exemple par un lecteur d'√©cran.
{% endaside %}

Et voici le r√©sultat :

{% codepen "https://codepen.io/bcalou/pen/eYqYMJg" %}

Maintenant, la m√™me chose, mais avec 100 √©mojis ! Bon, on s'amuse bien mais on va utiliser une [boucle SASS](https://sass-lang.com/documentation/at-rules/control/for/), on a pas que √ßa √† faire...

```scss
$emojis: "üí•", "üíã", "ü´Ä", "üëì", "üê∏", "üëë", "üê∞", "üêº", "üëã", "üê§", "üê±", "ü¶ä", "üê∑", "üôà", "üêù", "üêå", "üêû", "üê†", "üê¢", "üê´", "ü¶î", "ü¶ö", "üåπ", "üåº", "‚≠êÔ∏è", "üî•", "üëÄ", "üåà", "üíß", "üçâ", "üçì", "üçë", "ü•ù", "üçÜ", "ü•¶", "ü•®", "üßÄ", "üçî", "üçï", "üçô", "üéÇ", "üç≠", "üçø", "üç©", "üç∫", "üçπ", "üèÄ", "ü•ã", "üèÜ", "üéü", "üé≠", "üé®", "üé¨", "üéπ", "ü•Å", "üé∑", "üé∏", "ü™ó", "üé≤", "üéØ", "üé∞", "üé≥", "üö®", "üöá", "üöÄ", "üõ∏", "üõü", "üó∫", "‚õ±", "üåã", "üíª", "üñ®", "üíæ", "üïπ", "üíø", "üìº", "üì∏", "üìΩ", "üì†", "üì∫", "üß≠", "‚è∞", "‚è≥", "üí°", "üíµ", "üí∞", "üíé", "üîÆ", "üß¨", "üßª", "üéÅ", "üéà", "üéâ", "ü™©", "üì´", "üìö", "üîé", "ü©µ", "üíØ", "üîî", "üëÅ‚Äçüó®";

@keyframes emojis {
  @for $i from 1 through list.length($emojis) {
    #{($i - 1) * (100% / (list.length($emojis) - 1))} {
      content: list.nth($emojis, $i) / "";
    }
  }
}
```

Et quand 100 √©mojis d√©filent en quelques secondes seulement, eh bien √ßa donne √ßa :

{% codepen "https://codepen.io/bcalou/pen/xxvxYNL" %}

Le plus dur est fait. L'astuce r√©side dans le fait d'arr√™ter cette roulette infernale au survol.

```css
div:hover::before {
  animation-play-state: paused;
}
```

{% aside %}
L'√©l√©ment concern√© sur le site √©tant un lien, je peux aussi appliquer l'effet lorsque ce dernier obtient le focus. Une personne naviguant au clavier ¬´ profitera ¬ª ainsi de l'effet.
{% endaside %}

Survolez l'√©l√©ment : l'animation est arr√™t√©e net, et un emoji est ainsi ¬´ s√©lectionn√© ¬ª.

{% codepen "https://codepen.io/bcalou/pen/JjgjLWL" %}

Vous l'aurez compris, l'al√©atoire ici r√©side dans l'action de survol elle-m√™me, et plus pr√©cis√©ment dans son timing.

La touche finale, c'est bien s√ªr de cacher le pseudo-√©l√©ment jusqu'√† ce que le survol ait lieu :

```css
div::before {
  opacity: 0;
}

div:hover::before {
  opacity: 1;
  animation-play-state: paused;
}
```

Notre roulette invisible est pr√™te !

{% codepen "https://codepen.io/bcalou/pen/mdNdxwg" %}

En appliquant les m√™mes r√®gles au pseudo-√©l√©ment `after` et quelques tests de positionnement plus tard, le r√©sultat est l√†.

## Invisible... et pourtant, elle tourne

M√™me si je trouve cette technique int√©ressante √† partager, j'√©tais un peu g√™n√© une fois la mise en place effectu√©e.

C'est qu'il y a quelque chose d'un peu contre-nature √† changer de tr√®s nombreuses fois par seconde un contenu qu'on ne voit pas, non ?

Faisons une analyse de performance de la page, sur une minute, pour bien voir.

{% figure "perf1.png", "Analyse de performance de la d√©mo. On y voit d'innombrables barres verticales symbolisant les op√©rations.", "Chaque barre verticale est une op√©ration sollicitant la carte graphique." %}

Le navigateur est au repos 99% du temps. Pas la fin du monde, donc. Mais ces milliers de petites barres vertes, ce sont des milliers d'op√©rations parfaitement inutiles, ex√©cut√©es en permanence. Sur le principe, √ßa me g√™ne !

C'est un peu l'√©quivalent de pr√©parer une pizza, de la jeter directement √† la poubelle puis d'en pr√©parer une autre, et ainsi de suite jusqu'√† ce qu'un client ait enfin envie d'en profiter.

Alors, pour all√©ger un peu cette technique de gros bourrin, il y a une piste. Au lieu d'animer la propri√©t√© `content`, nous pouvons animer le contenu d'une variable CSS `--emoji`, et nous en servir pour g√©n√©rer le `content` uniquement lorsque l'√©l√©ment est survol√©.

```scss
div:hover::before {
  opacity: 1;
  animation-play-state: paused;
  content: var(--emoji);
}

@keyframes emojis {
  @for $i from 1 through list.length($emojis) {
    #{($i - 1) * (100% / (list.length($emojis) - 1))} {
      --emoji: "#{list.nth($emojis, $i)}" / "";
    }
  }
}
```

R√©sultat ?

{% figure "perf2.png", "Analyse de performance de la d√©mo ajust√©e. Il y a moins de barres verticales.", "La carte graphique est beaucoup moins sollicit√©e, mais il y a toujours √©norm√©ment d'op√©rations." %}

C√¥t√© performance, c'est maintenant √† 99,6% du temps que le navigateur est au repos. Beaucoup mieux !

Mais, fondamentalement, cela revient au m√™me : le navigateur doit suivre l'√©tat de cette variable en permanence, provoquant des milliers d'op√©rations superflues. J'aimerais savoir s'il est possible d'obtenir une version ¬´ propre ¬ª de cette approche. Mais j'en doute.

## La solution raisonnable

Mon cerveau est c√¢bl√© depuis longtemps pour commencer par envisager une solution purement CSS √† ce genre de probl√®me. M√™me quand √ßa ne marche pas, je d√©couvre toujours quelque chose.

Mais ici, c'est bien JavaScript qui nous apporte une solution simple et performante. Le code est sans grande surprise, en voici la partie principale :

```js
const emojis = ["üí•", "üíã", "ü´Ä", "üëì", "üê∏", "üëë", "üê∞", "üêº", ...];

function setRandomEmoji() {
  $target.style.setProperty(
    "--emoji",
    `"${emojis[Math.floor(Math.random() * emojis.length)]}" / ""`
  );
}

$target.addEventListener("mouseenter", setRandomEmoji);
```

Plus d'op√©rations inutiles !

Certes, CSS reste √† privil√©gier lorsque c'est possible. Mais il ne faut surtout pas rester bloqu√© sur un langage ou un autre lorsqu'il devient √©vident qu'une meilleure solution est √† chercher ailleurs.

## CSS n'a pas dit son dernier mot

Et [Houdini](https://developer.mozilla.org/en-US/docs/Web/API/Houdini_APIs), alors ? Cette API native permet de d√©finir, en JavaScript, des algorithmes de rendus invoquables par la suite en CSS.

Et effectivement, dans ce contexte-ci, l'al√©atoire est possible !

Voici la d√©finition d'une r√®gle `circle`, qui va g√©n√©rer al√©atoirement un cercle rouge ou vert.

```js
registerPaint('circle', class {
  paint(ctx, geom) {
    const x = geom.width / 2;
    const y = geom.height / 2;
    const radius = Math.min(x, y);

    ctx.fillStyle = Math.random() > 0.5 ? "red" : "green";

    ctx.beginPath();
    ctx.arc(x, y, radius, 0, 2 * Math.PI);
    ctx.fill();
  }
});
```

On l'utilise ainsi :

```css
div:hover {
  background: paint(circle);
}
```

Sympathique, car on laisse le navigateur s'occuper de la logique de survol, et les possibilit√©s ouvertes par Houdini sont bien plus vastes que mon simple exemple.

Malheureusement, ni Firefox ni Safari ne supportent cette API √† l'heure actuelle. Si vous √™tes sur un navigateur compatible, vous pourrez voir le r√©sultat en survolant le composant ci-dessous :

{% codepen "https://codepen.io/bcalou/pen/QWeWmop" %}

{% aside %}
Cela doit faire 5 ans que j'ai entendu parler d'Houdini, mais j'ai l'impression que le projet <a href="https://ishoudinireadyyet.com/">peine √† se concr√©tiser pleinement</a>. En tout cas, il semble avancer lentement. Il faut dire qu'un travail √©norme a √©t√© effectu√© ces derni√®res ann√©es sur des aspects bien plus fondamentaux de CSS !
{% endaside %}

Pour ma petite animation, le support limit√© d'Houdini passe encore : c'est une fonctionnalit√© ¬´ bonus ¬ª dont personne ne souffrira de l'absence.

Bien plus emb√™tant, impossible de trouver comment rendre du texte, et encore moins un √©moji. On dirait bien que cela est impossible...

## `random-item()` en CSS : c'est pr√©vu !

Les choses sont bien faites. Alors que je r√©fl√©chissais √† cet article, je suis tomb√© sur [cet article d'Alvaro Montoro](https://alvaromontoro.com/blog/68062/new-values-and-functions-in-CSS), qui d√©taille les nouveaut√©s √† venir concernant les valeurs et les fonctions en CSS (le niveau 5 du module <i>Values and Units</i>).

Et vous l'avez compris : parmi tout un tas de fonctionnalit√©s tr√®s prometteuses se trouve la tant fantasm√©e fonction `random-item()`.

Voici √† quoi pourrait ressembler mon code mis √† jour :

```css
div:hover:before {
  content: random-item(--x, "üí•", "üíã", "ü´Ä", "üëì", "üê∏", "üëë",...);
}
```

{% aside %}
Si j'ai bien compris, le <code>--x</code> servira √† ¬´ identifier ¬ª le g√©n√©rateur. Tous les appels √† <code>random-item()</code> poss√©dant le m√™me identifiant et la m√™me liste g√©n√®reront la m√™me valeur sur la page.
{% endaside %}

Plus simplement, la fonction `random()` permettra d'obtenir une valeur al√©atoire entre deux bornes :

```css
div {
  width: random(0vw, 100vw);
}
```

Encore une tr√®s bonne nouvelle pour CSS, donc.

Quand cela sera-t-il disponible ? Pour nous autres mortels, cela aussi rel√®ve du domaine de l'al√©atoire...
<!-- 
<iframe src="https://piaille.fr/@bcalou/113163065917919388/embed" class="mastodon-embed" style="max-width: 100%; border: 0" width="400" allowfullscreen="allowfullscreen"></iframe><script src="https://piaille.fr/embed.js" async="async"></script> -->